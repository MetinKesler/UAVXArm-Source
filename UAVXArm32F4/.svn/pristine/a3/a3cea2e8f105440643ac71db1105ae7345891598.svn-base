// ===============================================================================================
// =                                UAVX Quadrocopter ContRoller                                 =
// =                           Copyright (c) 2008 by Prof. Greg Egan                             =
// =                 Original V3.15 Copyright (c) 2007 Ing. Wolfgang Mahringer                   =
// =                     http://code.google.com/p/uavp-mods/ http://uavp.ch                      =
// ===============================================================================================

//    This is part of UAVX.

//    UAVX is free software: you can redistribute it and/or modify it under the terms of the GNU
//    General Public License as published by the Free Software Foundation, either version 3 of the
//    License, or (at your option) any later version.

//    UAVX is distributed in the hope that it will be useful,but WITHOUT ANY WARRANTY; without
//    even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
//    See the GNU General Public License for more details.

//    You should have received a copy of the GNU General Public License aint32 with this program.
//    If not, see http://www.gnu.org/licenses/


#include "UAVX.h"

#define MAX_YAW_RATE_RADPS DegreesToRadians(60) // TODO: 180 may be too high - above this rate AHRS compensation of heading is zero
real32 dT, dTR, dTOn2, dTROn2;
uint32 LastInertialUpdateuS = 0;
real32 AccConfidenceSDevR = 5.0f;
real32 AccConfidence;
real32 AccZ;
real32 MagConfidence;
real32 EstMagHeading = 0.0f;

real32 CalculateAccConfidence(real32 AccMag) {
	// Gaussian decay in accelerometer value belief
	static real32 confp = 1.0f;
	real32 conf, accNorm;

	accNorm = AccMag * GRAVITY_MPS_S_R;
	conf = expf(-0.5f * Sqr(Abs(accNorm - 1.0f) * AccConfidenceSDevR));
	confp = HardFilter(confp, conf);

	return (confp);
} // CalculateAccConfidence


real32 CalculateMagConfidence(void) {
	// reduce confidence in mag for high yaw rates
	real32 c;

	if (State == InFlight) {
		c = KpMagBase * (1.0f - Rate[Yaw] / MAX_YAW_RATE_RADPS); // linear for now
		c = Limit(c, 0.0f, KpMagBase);
	} else
		c = KpMagBase * 10.0;

	return (c);
} // CalculateMagConfidence

//=====================================================================================================
// AHRS
// S.O.H. Madgwick
// 25th August 2010
//=====================================================================================================
// Description:
//
// Quaternion implementation of the 'DCM filter' [Mayhony et al].  Incorporates the magnetic distortion
// compensation algorithms from my filter [Madgwick] which eliminates the need for a reference
// direction of flux (bx bz) to be predefined and limits the effect of magnetic distortions to yaw
// axis only.
//
// Gyroscope units are radians/second, accelerometer and magnetometer units are irrelevant as the
// vector is normalised.
//
// adapted from John Ihlein's AQ version translated to Aerospace Coordinates
//
// integral terms removed and accelerometer & magnetometer confidence scheme by Prof. G.K. Egan 2012
//
//=====================================================================================================

real32 KpAccBase = 2.0f; // was 5.0f;
real32 KpAcc;
real32 KpMagBase = 5.0f;
real32 KpMag;

real32 q0, q1, q2, q3;
real32 q0q0, q0q1, q0q2, q0q3;
real32 q1q1, q1q2, q1q3;
real32 q2q2, q2q3;
real32 q3q3;

real32 bi00, bi01, bi02;
real32 bi10, bi11, bi12;
real32 bi20, bi21, bi22;

void InitMadgwick(void) {

	q0 = 1.0f; // cosf(MagHeading * 0.5f);
	q1 = 0.0f;
	q2 = 0.0f;
	q3 = 0.0f; // sinf(MagHeading * 0.5f);

	q0q0 = q0 * q0;
	q0q1 = q0 * q1;
	q0q2 = q0 * q2;
	q0q3 = q0 * q3;
	q1q1 = q1 * q1;
	q1q2 = q1 * q2;
	q1q3 = q1 * q3;
	q2q2 = q2 * q2;
	q2q3 = q2 * q3;
	q3q3 = q3 * q3;

} // InitMadgwick

void VersanoCompensation(void) {
#if defined(USE_VERSANO_GRAVITY_COMP)
	// http://www.varesano.net/blog/fabio/simple-gravity-compensation-9-dom-imus
	// compensate the accelerometer readings from gravity.

	real32 cx, cy, cz;

	// get expected direction of gravity from previous iteration!
	cx = 2.0f * (q1q3 - q0q2);
	cy = 2.0f * (q0q1 + q2q3);
	cz = q0q0 - q1q1 - q2q2 + q3q3;

	ax -= cx;
	ay -= cy;
	az -= cz;

#endif
}

real32 GravityCompensatedAccZ(void) {

	return 2.0f * (q1q3 - q0q2) * Acc[X] + 2.0f * (q0q1 + q2q3) * Acc[Y]
			+ (q0q0 - q1q1 - q2q2 + q3q3) * Acc[Z] + GRAVITY_MPS_S;
} // GravityCompensatedAccZ

real32 AttitudeCosine(void) { // for attitude throttle compensation

	return q0q0 - q1q1 - q2q2 + q3q3;

} // AttitudeCosine


void UpdateBodyToInertialTransform(void) {

	bi00 = q0q0 + q1q1 - q2q2 - q3q3; // yaw
	//bi01 = 2.0f * (q1q2 - q0q3);
	//bi02 = 2.0f * (q0q2 + q1q3);

	bi10 = 2.0f * (q1q2 + q0q3);
	//bi11 = q0q0 - q1q1 + q2q2 - q3q3; // yaw
	//bi12 = 2.0f * (q2q3 - q0q1);

	bi20 = 2.0f * (q1q3 - q0q2); // pitch gx
	bi21 = 2.0f * (q0q1 + q2q3); // roll gy
	bi22 = q0q0 - q1q1 - q2q2 + q3q3; // yaw gz

	A[Roll].Angle = atan2f(bi21, bi22);
	A[Pitch].Angle = -asinf(bi20);
	A[Yaw].Angle = atan2f(bi10, bi00);

} // UpdateBodyToInertialTransform


void MadgwickDCTUpdate(real32 gx, real32 gy, real32 gz, real32 ax, real32 ay,
		real32 az, real32 mx, real32 my, real32 mz) {

	real32 NormR;

	real32 q0i, q1i, q2i, q3i;
	real32 hx, hy, hz;
	real32 bx, bz;
	real32 vx, vy, vz;
	real32 wx, wy, wz;

	// estimated direction of gravity (v)
	vx = 2.0f * (q1q3 - q0q2);
	vy = 2.0f * (q0q1 + q2q3);
	vz = q0q0 - q1q1 - q2q2 + q3q3;

	// error is sum of cross product between reference direction
	// of fields and direction measured by sensors

	real32 AccMag = sqrtf(Sqr(ax) + Sqr(ay) + Sqr(az));
	AccConfidence = CalculateAccConfidence(AccMag);

	// renormalise to attempt to remove a little acc vibration noise
	NormR = 1.0f / AccMag;
	ax *= NormR;
	ay *= NormR;
	az *= NormR;

	KpAcc = State == InFlight ? KpAccBase * AccConfidence : KpAccBase * 5.0f;
	gx += (vy * az - vz * ay) * KpAcc;
	gy += (vz * ax - vx * az) * KpAcc;
	gz += (vx * ay - vy * ax) * KpAcc;

	// integrate quaternion rate
	q0i = (-q1 * gx - q2 * gy - q3 * gz) * dTOn2;
	q1i = (q0 * gx + q2 * gz - q3 * gy) * dTOn2;
	q2i = (q0 * gy - q1 * gz + q3 * gx) * dTOn2;
	q3i = (q0 * gz + q1 * gy - q2 * gx) * dTOn2;
	q0 += q0i;
	q1 += q1i;
	q2 += q2i;
	q3 += q3i;

	// normalize quaternion
	NormR = invSqrt(Sqr(q0) + Sqr(q1) + Sqr(q2) + Sqr(q3));
	q0 *= NormR;
	q1 *= NormR;
	q2 *= NormR;
	q3 *= NormR;

	q0q0 = q0 * q0;
	q0q1 = q0 * q1;
	q0q2 = q0 * q2;
	q0q3 = q0 * q3;
	q1q1 = q1 * q1;
	q1q2 = q1 * q2;
	q1q3 = q1 * q3;
	q2q2 = q2 * q2;
	q2q3 = q2 * q3;
	q3q3 = q3 * q3;

	UpdateBodyToInertialTransform();

} // MadgwickDCTUpdate

void UpdateHeading(void) {

	if (F.Emulation) {
		EstMagHeading += Rate[Yaw] * dT;
		EstMagHeading = Make2Pi(EstMagHeading);
		MagHeading = EstMagHeading;
		Heading = Make2Pi(MagHeading + MagVariation);
	} else {
		GetMagnetometer();
		if (F.NewMagValues) {
			CalculateMagneticHeading();
			Heading = Make2Pi(MagHeading + MagVariation);
		}
	}
} // UpdateHeading


void UpdateMadgwick(void) {
	int32 a;

	if (F.Emulation)
		DoEmulation(); // produces ROC, Altitude etc.
	else
		GetIMU();

	MadgwickDCTUpdate(Rate[Roll], Rate[Pitch], Rate[Yaw], Acc[BF], Acc[LR],
			Acc[UD], Mag[X], Mag[Y], Mag[Z]);

	DoControl();

	UpdateMadgwickHeading();

	UpdateGPS();
	if (F.NewGPSPosition) {
		F.NewGPSPosition = false;
		for (a = NorthC; a <= DownC; a++) {
			Nav.Pos[a] = GPS.Pos[a];
			Nav.Vel[a] = GPS.Vel[a];
		}
		CheckNavEnable();
	}

	if (F.Emulation) {
		RangefinderAltitude = BaroAltitude - OriginAltitude;
		F.UsingRangefinderAlt = RangefinderAltitude <= RF[RFType].maxAlt;
		//F.NearLevel &&
	} else {
		Airspeed = 0.5f * (AS_MIN_MPS + AS_MAX_MPS); // TODO: Airspeed call in altitude/atmosphere stuff
		UpdateAltitudeEstimates();
	}

}// UpdateMadgwick

//____________________________________________________________________________


void CheckNavEnable(void) {

	if ((mSClock() > mS[NavActiveTime]) && !F.NavigationActive) {
		F.NavigationActive = true;
		ResumeHoldingStation();
		NavSwStateP = NavSwUnknown;
	}

	//	if (!F.NavigationEnabled)
	//		AcquireHoldPosition();

	F.GPSPosUpdated = true; // for telemetry
	F.NewNavUpdate = F.NavigationEnabled && !F.Bypass;

} // CheckNavEnable

